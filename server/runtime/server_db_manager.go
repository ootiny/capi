// tag-rt-api-builder-start: This file is generated by rt-builder, DO NOT EDIT.
package runtime

import (
	"database/sql"
	"embed"
	"fmt"
	"io/fs"
	"strings"
	"sync"
)

type SQLManager struct {
	agent    ISqlAgent
	config   *DBConfig
	dbAssets *embed.FS
	db       *sql.DB
	tableMap map[string]*DBTable
	mutex    *sync.Mutex
}

func NewSQLManager(dbAssets *embed.FS) (*SQLManager, error) {
	if dbAssets == nil {
		return nil, fmt.Errorf("dbAssets is nil")
	} else if configContent, err := dbAssets.ReadFile("config.json"); err != nil {
		return nil, WrapError(err)
	} else if config, err := LoadDBConfig(string(configContent)); err != nil {
		return nil, WrapError(err)
	} else {
		agent := ISqlAgent(nil)

		switch config.Connect.Driver {
		case "postgres":
			agent = NewPGAgent()
		default:
			return nil, fmt.Errorf("invalid driver name %s", config.Connect.Driver)
		}

		if db, err := sql.Open(
			config.Connect.Driver,
			agent.DataSource(
				config.Connect.Host,
				config.Connect.Port,
				config.Connect.User,
				config.Connect.Password,
				config.Connect.DBName,
			),
		); err != nil {
			return nil, err
		} else {
			return &SQLManager{
				agent:    agent,
				config:   config,
				dbAssets: dbAssets,
				db:       db,
				tableMap: make(map[string]*DBTable),
				mutex:    &sync.Mutex{},
			}, nil
		}
	}
}

func (p *SQLManager) CreateDatabaseIfNotExist() (err error) {
	connect := p.config.Connect
	dataSource := p.agent.DataSource(connect.Host, connect.Port, connect.User, connect.Password, "")

	if db, err := sql.Open(connect.Driver, dataSource); err != nil {
		return err
	} else {
		defer func() {
			err = FirstError(err, WrapError(db.Close()))
		}()

		var exists bool

		if err = db.QueryRow(p.agent.HasDatabase(connect.DBName)).Scan(&exists); err != nil {
			return WrapError(err)
		}

		if !exists {
			if _, err = db.Exec(p.agent.CreateDatabase(connect.DBName)); err != nil {
				return WrapError(err)
			}
		}

		return nil
	}
}

func (p *SQLManager) NewTransaction(isolationLevel string, readOnly bool) *SQLTransaction {
	return &SQLTransaction{
		tx:             nil,
		dbMgr:          p,
		isolationLevel: isolationLevel,
		readOnly:       readOnly,
		mutex:          &sync.Mutex{},
	}
}

func (p *SQLManager) GetService(name string) *DBTable {
	return p.tableMap[name]
}

func (p *SQLManager) GetViewConfig(table string, view string) *DBTableView {
	if tableMeta, ok := p.tableMap[table]; !ok {
		return nil
	} else {
		return tableMeta.Views[view]
	}
}

func (p *SQLManager) GetColumnType(table string, column string) string {
	if tableMeta, ok := p.tableMap[table]; !ok {
		return ""
	} else {
		return tableMeta.Columns[column].Type
	}
}

func (p *SQLManager) Open() error {
	// find all db table configs file
	files := make([]string, 0)
	if e := fs.WalkDir(
		p.dbAssets,
		".",
		func(path string, d fs.DirEntry, err error) error {
			if path == "config.json" {
				return nil
			}

			if err != nil {
				return err
			}

			if !d.IsDir() && strings.HasSuffix(path, ".json") {
				files = append(files, path)
			}

			return nil
		},
	); e != nil {
		return WrapError(e)
	}

	// load db configs
	tx := p.NewTransaction(SqlLevelSerializable, false)

	for _, file := range files {
		if fContent, e := p.dbAssets.ReadFile(file); e != nil {
			_ = tx.Close(false)
			return WrapError(e)
		} else if table, e := LoadDBTable(string(fContent)); e != nil {
			_ = tx.Close(false)
			return WrapError(e).AddHeader(file)
		} else if _, ok := p.tableMap[table.Table]; ok {
			_ = tx.Close(false)
			return Errorf(
				"db-manager: duplicated table %s",
				table.Table,
			)
		} else if e := tx.UpdateTable(string(fContent)); e != nil {
			_ = tx.Close(false)
			return WrapError(e)
		} else {
			p.tableMap[table.Table] = table
		}
	}

	// check link
	for tableName, tableConfig := range p.tableMap {
		for viewName, viewConfig := range tableConfig.Views {
			for _, columnConfig := range viewConfig.Columns {
				if columnConfig.LinkTable == "" {
					continue
				}

				if _, ok := p.tableMap[columnConfig.LinkTable]; !ok {
					_ = tx.Close(false)
					return Errorf(
						"%s: Views.%s.columns.%s invalid link table: %s",
						tableName,
						viewName,
						columnConfig.Name,
						columnConfig.LinkTable,
					)
				}

				if _, ok := p.tableMap[columnConfig.LinkTable].Views[columnConfig.LinkView]; !ok {
					_ = tx.Close(false)
					return Errorf(
						"%s: Views.%s.columns.%s invalid link view: %s",
						tableName,
						viewName,
						columnConfig.Name,
						columnConfig.LinkView,
					)
				}
			}
		}
	}

	if e := tx.Close(true); e != nil {
		return WrapError(e)
	} else {
		return nil
	}
}

func (p *SQLManager) Close() error {
	if p.db != nil {
		ret := WrapError(p.db.Close())
		p.db = nil
		return ret
	} else {
		return nil
	}
}

// tag-rt-api-builder-end
